#version 330 core

uniform int numLights; // number of lights
uniform int mode; // rendering mode
uniform int lightType; // 0 = point, 1 = spotlight, 2 = directional

uniform vec3 eyePosition;
uniform vec3 lightPositions[10]; // positions for point or spotlight
uniform vec3 spotDirection;
uniform float spotCutoff;
uniform vec3 directionalDirection; // direction for directional light

// material properties
uniform vec3 ambientColor;
uniform vec3 diffuseColor;
uniform vec3 specularColor;

uniform float kAmbient; // ambient reflection coefficient
uniform float kDiffuse; // diffuse reflection coefficient
uniform float kSpecular; // specular reflection coefficient
uniform float kShininess; // shininess

// input variables; from the vertex shader
in vec3 worldPosition; // vertex position; in world space
in vec3 worldNormal; // surface normal; in world space

// output variable for fragment color
out vec4 fragmentColor;

void main() {
    vec3 tmpColor = vec3(0.f);
    vec3 N = normalize(worldNormal);

    for (int i = 0; i < numLights; i++) {
        vec3 L;
        float lambertian = 0.f;
        float specular = 0.f;

        if (lightType == 0) { // Point light
            L = normalize(lightPositions[i] - worldPosition);
        } else if (lightType == 1) { // Spotlight
            L = normalize(lightPositions[i] - worldPosition);
            vec3 S = normalize(spotDirection);
            float spot = dot(-L, S);
            if (spot < spotCutoff) {
                lambertian = 0.f;
                specular = 0.f;
                continue;
            }
            spot = (spot - spotCutoff) / (1 - spotCutoff);
        } else if (lightType == 2) { // Directional light
            L = normalize(-directionalDirection); // Direction to the light source
        }

        // Lambert's cosine law
        lambertian = max(dot(N, L), 0.f);

        if (lambertian > 0.f) { // Specular only if the light hits the front side
            vec3 R = reflect(-L, N); // Reflected light vector
            vec3 V = normalize(eyePosition - worldPosition); // Vector to viewer
            specular = pow(max(dot(R, V), 0.f), kShininess);
        }

        // Add the current light contribution value
        if (mode == 0) // all components
            tmpColor += (kDiffuse * lambertian * diffuseColor +
                         kSpecular * specular * specularColor);
        else if (mode == 2) // diffuse only
            tmpColor += kDiffuse * lambertian * diffuseColor;
        else if (mode == 3) // specular only
            tmpColor += kSpecular * specular * specularColor;
    }

    if (mode == 0 || mode == 1) // all components or ambient only
        tmpColor += kAmbient * ambientColor;

    fragmentColor = vec4(tmpColor, 1.f);
}
